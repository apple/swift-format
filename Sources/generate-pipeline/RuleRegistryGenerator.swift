//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2019 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

import Foundation
import SwiftSyntax

/// Generates the rule registry file used to populate the default configuration.
final class RuleRegistryGenerator: FileGenerator {

  /// The rules collected by scanning the formatter source code.
  let ruleCollector: RuleCollector

  /// Creates a new rule registry generator.
  init(ruleCollector: RuleCollector) {
    self.ruleCollector = ruleCollector
  }

  func write(into handle: FileHandle) throws {
    // enum RuleRegistry {
    //   static let rules: [String: Bool] = [
    //     "AllPublicDeclarationsHaveDocumentation": true,
    //   ]
    // }
    writeRuleRegistry(to: handle)
  }

  private func writeRuleRegistry(to handle: FileHandle) {
    let sourceComment = """
    //===----------------------------------------------------------------------===//
    //
    // This source file is part of the Swift.org open source project
    //
    // Copyright (c) 2014 - 2019 Apple Inc. and the Swift project authors
    // Licensed under Apache License v2.0 with Runtime Library Exception
    //
    // See https://swift.org/LICENSE.txt for license information
    // See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
    //
    //===----------------------------------------------------------------------===//

    // This file is automatically generated with generate-pipeline. Do Not Edit!

    """

    let variableDecl = makeVariableDecl()
    let memberDeclItem = SyntaxFactory.makeMemberDeclListItem(
      decl: variableDecl,
      semicolon: nil
    )
    let memberDeclBlock = SyntaxFactory.makeMemberDeclBlock(
      leftBrace: SyntaxFactory.makeLeftBraceToken(),
      members: SyntaxFactory.makeMemberDeclList([memberDeclItem]),
      rightBrace: SyntaxFactory.makeRightBraceToken(leadingTrivia: .newlines(1), trailingTrivia: .newlines(1))
    )
    let enumDecl = SyntaxFactory.makeEnumDecl(
      attributes: nil,
      modifiers: nil,
      enumKeyword: SyntaxFactory.makeEnumKeyword(
        leadingTrivia: .init(pieces: [.lineComment(sourceComment), .newlines(1)]),
        trailingTrivia: .spaces(1)
      ),
      identifier: SyntaxFactory.makeIdentifier("RuleRegistry", trailingTrivia: .spaces(1)),
      genericParameters: nil,
      inheritanceClause: nil,
      genericWhereClause: nil,
      members: memberDeclBlock
    )
    handle.write(enumDecl.description)
  }
    
  private func makeVariableDecl() -> VariableDeclSyntax {
    let modifierDecl = SyntaxFactory.makeDeclModifier(
      name: SyntaxFactory.makeStaticKeyword(
        leadingTrivia: .init(pieces: [.newlines(1), .spaces(2)]),
        trailingTrivia: .spaces(1)
      ),
      detailLeftParen: nil,
      detail: nil,
      detailRightParen: nil
    )
    let dictionaryType = SyntaxFactory.makeDictionaryType(
      leftSquareBracket: SyntaxFactory.makeLeftSquareBracketToken(),
      keyType: SyntaxFactory.makeTypeIdentifier("String"),
      colon: SyntaxFactory.makeColonToken(trailingTrivia: .spaces(1)),
      valueType: SyntaxFactory.makeTypeIdentifier("Bool"),
      rightSquareBracket: SyntaxFactory.makeRightSquareBracketToken(trailingTrivia: .spaces(1))
    )
    let typeAnnotation = SyntaxFactory.makeTypeAnnotation(
      colon: SyntaxFactory.makeColonToken(trailingTrivia: .spaces(1)),
      type: dictionaryType)

    var dictionaryElements: [DictionaryElementSyntax] = []
    for ruleName in ruleCollector.allLinters.sorted() {
      let dictionaryElement = SyntaxFactory.makeDictionaryElement(
        keyExpression: SyntaxFactory.makeStringLiteralExpr(
          ruleName,
          leadingTrivia: .init(pieces: [.newlines(1), .spaces(4)])
        ),
        colon: SyntaxFactory.makeColonToken(trailingTrivia: .spaces(1)),
        valueExpression: SyntaxFactory.makeBooleanLiteralExpr(booleanLiteral: SyntaxFactory.makeTrueKeyword()),
        trailingComma: SyntaxFactory.makeCommaToken()
      )
      dictionaryElements.append(dictionaryElement)
    }

    let dictionaryElementList = SyntaxFactory.makeDictionaryElementList(dictionaryElements)
    let dictionaryExpr = SyntaxFactory.makeDictionaryExpr(
      leftSquare: SyntaxFactory.makeLeftSquareBracketToken(),
      content: dictionaryElementList,
      rightSquare: SyntaxFactory.makeRightSquareBracketToken(leadingTrivia: .init(pieces: [.newlines(1), .spaces(2)]))
    )
    let initializerClause = SyntaxFactory.makeInitializerClause(
      equal: SyntaxFactory.makeEqualToken(trailingTrivia: .spaces(1)),
      value: dictionaryExpr
    )
    let patternBinding = SyntaxFactory.makePatternBinding(
      pattern: SyntaxFactory.makeIdentifierPattern(identifier: SyntaxFactory.makeIdentifier("rules")),
      typeAnnotation: typeAnnotation,
      initializer: initializerClause,
      accessor: nil,
      trailingComma: nil
    )
    return SyntaxFactory.makeVariableDecl(
      attributes: nil,
      modifiers: SyntaxFactory.makeModifierList([modifierDecl]),
      letOrVarKeyword: SyntaxFactory.makeLetKeyword(trailingTrivia: .spaces(1)),
      bindings: SyntaxFactory.makePatternBindingList([patternBinding])
    )
  }
}
